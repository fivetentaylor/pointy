// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"

	"gorm.io/gen"

	"gorm.io/plugin/dbresolver"
)

var (
	Q                  = new(Query)
	AuthorID           *authorID
	Comment            *comment
	DefaultDocument    *defaultDocument
	Document           *document
	DocumentAccess     *documentAccess
	DocumentAttachment *documentAttachment
	DocumentVersion    *documentVersion
	OneTimeAccessToken *oneTimeAccessToken
	PaymentHistory     *paymentHistory
	Prompt             *prompt
	SchemaMigration    *schemaMigration
	SharedDocumentLink *sharedDocumentLink
	StripeWebhookEvent *stripeWebhookEvent
	SubscriptionPlan   *subscriptionPlan
	User               *user
	UserSubscription   *userSubscription
	WaitlistUser       *waitlistUser
)

func SetDefault(db *gorm.DB, opts ...gen.DOOption) {
	*Q = *Use(db, opts...)
	AuthorID = &Q.AuthorID
	Comment = &Q.Comment
	DefaultDocument = &Q.DefaultDocument
	Document = &Q.Document
	DocumentAccess = &Q.DocumentAccess
	DocumentAttachment = &Q.DocumentAttachment
	DocumentVersion = &Q.DocumentVersion
	OneTimeAccessToken = &Q.OneTimeAccessToken
	PaymentHistory = &Q.PaymentHistory
	Prompt = &Q.Prompt
	SchemaMigration = &Q.SchemaMigration
	SharedDocumentLink = &Q.SharedDocumentLink
	StripeWebhookEvent = &Q.StripeWebhookEvent
	SubscriptionPlan = &Q.SubscriptionPlan
	User = &Q.User
	UserSubscription = &Q.UserSubscription
	WaitlistUser = &Q.WaitlistUser
}

func Use(db *gorm.DB, opts ...gen.DOOption) *Query {
	return &Query{
		db:                 db,
		AuthorID:           newAuthorID(db, opts...),
		Comment:            newComment(db, opts...),
		DefaultDocument:    newDefaultDocument(db, opts...),
		Document:           newDocument(db, opts...),
		DocumentAccess:     newDocumentAccess(db, opts...),
		DocumentAttachment: newDocumentAttachment(db, opts...),
		DocumentVersion:    newDocumentVersion(db, opts...),
		OneTimeAccessToken: newOneTimeAccessToken(db, opts...),
		PaymentHistory:     newPaymentHistory(db, opts...),
		Prompt:             newPrompt(db, opts...),
		SchemaMigration:    newSchemaMigration(db, opts...),
		SharedDocumentLink: newSharedDocumentLink(db, opts...),
		StripeWebhookEvent: newStripeWebhookEvent(db, opts...),
		SubscriptionPlan:   newSubscriptionPlan(db, opts...),
		User:               newUser(db, opts...),
		UserSubscription:   newUserSubscription(db, opts...),
		WaitlistUser:       newWaitlistUser(db, opts...),
	}
}

type Query struct {
	db *gorm.DB

	AuthorID           authorID
	Comment            comment
	DefaultDocument    defaultDocument
	Document           document
	DocumentAccess     documentAccess
	DocumentAttachment documentAttachment
	DocumentVersion    documentVersion
	OneTimeAccessToken oneTimeAccessToken
	PaymentHistory     paymentHistory
	Prompt             prompt
	SchemaMigration    schemaMigration
	SharedDocumentLink sharedDocumentLink
	StripeWebhookEvent stripeWebhookEvent
	SubscriptionPlan   subscriptionPlan
	User               user
	UserSubscription   userSubscription
	WaitlistUser       waitlistUser
}

func (q *Query) Available() bool { return q.db != nil }

func (q *Query) clone(db *gorm.DB) *Query {
	return &Query{
		db:                 db,
		AuthorID:           q.AuthorID.clone(db),
		Comment:            q.Comment.clone(db),
		DefaultDocument:    q.DefaultDocument.clone(db),
		Document:           q.Document.clone(db),
		DocumentAccess:     q.DocumentAccess.clone(db),
		DocumentAttachment: q.DocumentAttachment.clone(db),
		DocumentVersion:    q.DocumentVersion.clone(db),
		OneTimeAccessToken: q.OneTimeAccessToken.clone(db),
		PaymentHistory:     q.PaymentHistory.clone(db),
		Prompt:             q.Prompt.clone(db),
		SchemaMigration:    q.SchemaMigration.clone(db),
		SharedDocumentLink: q.SharedDocumentLink.clone(db),
		StripeWebhookEvent: q.StripeWebhookEvent.clone(db),
		SubscriptionPlan:   q.SubscriptionPlan.clone(db),
		User:               q.User.clone(db),
		UserSubscription:   q.UserSubscription.clone(db),
		WaitlistUser:       q.WaitlistUser.clone(db),
	}
}

func (q *Query) ReadDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Read))
}

func (q *Query) WriteDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Write))
}

func (q *Query) ReplaceDB(db *gorm.DB) *Query {
	return &Query{
		db:                 db,
		AuthorID:           q.AuthorID.replaceDB(db),
		Comment:            q.Comment.replaceDB(db),
		DefaultDocument:    q.DefaultDocument.replaceDB(db),
		Document:           q.Document.replaceDB(db),
		DocumentAccess:     q.DocumentAccess.replaceDB(db),
		DocumentAttachment: q.DocumentAttachment.replaceDB(db),
		DocumentVersion:    q.DocumentVersion.replaceDB(db),
		OneTimeAccessToken: q.OneTimeAccessToken.replaceDB(db),
		PaymentHistory:     q.PaymentHistory.replaceDB(db),
		Prompt:             q.Prompt.replaceDB(db),
		SchemaMigration:    q.SchemaMigration.replaceDB(db),
		SharedDocumentLink: q.SharedDocumentLink.replaceDB(db),
		StripeWebhookEvent: q.StripeWebhookEvent.replaceDB(db),
		SubscriptionPlan:   q.SubscriptionPlan.replaceDB(db),
		User:               q.User.replaceDB(db),
		UserSubscription:   q.UserSubscription.replaceDB(db),
		WaitlistUser:       q.WaitlistUser.replaceDB(db),
	}
}

type queryCtx struct {
	AuthorID           IAuthorIDDo
	Comment            ICommentDo
	DefaultDocument    IDefaultDocumentDo
	Document           IDocumentDo
	DocumentAccess     IDocumentAccessDo
	DocumentAttachment IDocumentAttachmentDo
	DocumentVersion    IDocumentVersionDo
	OneTimeAccessToken IOneTimeAccessTokenDo
	PaymentHistory     IPaymentHistoryDo
	Prompt             IPromptDo
	SchemaMigration    ISchemaMigrationDo
	SharedDocumentLink ISharedDocumentLinkDo
	StripeWebhookEvent IStripeWebhookEventDo
	SubscriptionPlan   ISubscriptionPlanDo
	User               IUserDo
	UserSubscription   IUserSubscriptionDo
	WaitlistUser       IWaitlistUserDo
}

func (q *Query) WithContext(ctx context.Context) *queryCtx {
	return &queryCtx{
		AuthorID:           q.AuthorID.WithContext(ctx),
		Comment:            q.Comment.WithContext(ctx),
		DefaultDocument:    q.DefaultDocument.WithContext(ctx),
		Document:           q.Document.WithContext(ctx),
		DocumentAccess:     q.DocumentAccess.WithContext(ctx),
		DocumentAttachment: q.DocumentAttachment.WithContext(ctx),
		DocumentVersion:    q.DocumentVersion.WithContext(ctx),
		OneTimeAccessToken: q.OneTimeAccessToken.WithContext(ctx),
		PaymentHistory:     q.PaymentHistory.WithContext(ctx),
		Prompt:             q.Prompt.WithContext(ctx),
		SchemaMigration:    q.SchemaMigration.WithContext(ctx),
		SharedDocumentLink: q.SharedDocumentLink.WithContext(ctx),
		StripeWebhookEvent: q.StripeWebhookEvent.WithContext(ctx),
		SubscriptionPlan:   q.SubscriptionPlan.WithContext(ctx),
		User:               q.User.WithContext(ctx),
		UserSubscription:   q.UserSubscription.WithContext(ctx),
		WaitlistUser:       q.WaitlistUser.WithContext(ctx),
	}
}

func (q *Query) Transaction(fc func(tx *Query) error, opts ...*sql.TxOptions) error {
	return q.db.Transaction(func(tx *gorm.DB) error { return fc(q.clone(tx)) }, opts...)
}

func (q *Query) Begin(opts ...*sql.TxOptions) *QueryTx {
	tx := q.db.Begin(opts...)
	return &QueryTx{Query: q.clone(tx), Error: tx.Error}
}

type QueryTx struct {
	*Query
	Error error
}

func (q *QueryTx) Commit() error {
	return q.db.Commit().Error
}

func (q *QueryTx) Rollback() error {
	return q.db.Rollback().Error
}

func (q *QueryTx) SavePoint(name string) error {
	return q.db.SavePoint(name).Error
}

func (q *QueryTx) RollbackTo(name string) error {
	return q.db.RollbackTo(name).Error
}
