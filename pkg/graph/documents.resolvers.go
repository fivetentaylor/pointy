package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"context"
	"fmt"
	"time"

	"github.com/charmbracelet/log"
	"github.com/fivetentaylor/pointy/pkg/env"
	"github.com/fivetentaylor/pointy/pkg/graph/loaders"
	"github.com/fivetentaylor/pointy/pkg/graph/model"
	"github.com/fivetentaylor/pointy/pkg/models"
	"github.com/fivetentaylor/pointy/pkg/query"
	"github.com/fivetentaylor/pointy/pkg/rogue"
	"github.com/fivetentaylor/pointy/pkg/service/document"
	"github.com/fivetentaylor/pointy/pkg/service/pubsub"
	"github.com/fivetentaylor/pointy/pkg/service/timeline"
	"github.com/fivetentaylor/pointy/pkg/stackerr"
	"github.com/fivetentaylor/pointy/pkg/storage/dynamo"
)

// OwnedBy is the resolver for the ownedBy field.
func (r *documentResolver) OwnedBy(ctx context.Context, obj *models.Document) (*models.User, error) {
	user, err := loaders.GetDocumentOwner(ctx, obj.ID)
	if err != nil {
		if err.Error() == "record not found" {
			return &models.User{
				ID:   "00000000-0000-0000-0000-000000000000",
				Name: "Anonymous",
			}, nil
		}
		log.Errorf("error getting document owner: %s", stackerr.Wrap(err))
		return nil, err
	}

	return user, nil
}

// Editors is the resolver for the editors field
func (r *documentResolver) Editors(ctx context.Context, obj *models.Document) ([]*models.User, error) {
	userTbl := env.Query(ctx).User
	docAccessTbl := env.Query(ctx).DocumentAccess

	editors, err := userTbl.
		LeftJoin(docAccessTbl, userTbl.ID.EqCol(docAccessTbl.UserID)).
		Where(docAccessTbl.DocumentID.Eq(obj.ID)).
		Where(docAccessTbl.AccessLevel.In("owner", "write")).Find()

	if err != nil {
		log.Errorf("error getting document owner: %s", stackerr.Wrap(err))
		return nil, err
	}

	return editors, nil
}

// HasUnreadNotifications is the resolver for the hasUnreadNotifications field.
func (r *documentResolver) HasUnreadNotifications(ctx context.Context, obj *models.Document) (bool, error) {
	log := env.Log(ctx)

	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return false, fmt.Errorf("please login")
	}

	count, err := env.Dynamo(ctx).GetNotificationCountForUserAndDocument(currentUser.Id, obj.ID, false)
	if err != nil {
		log.Errorf("error getting unread notification count: %s", err)
		return false, fmt.Errorf("error getting unread notification count: %s", err)
	}

	return count > 0, nil
}

// Preferences is the resolver for the preferences field.
func (r *documentResolver) Preferences(ctx context.Context, obj *models.Document) (*models.DocumentPreference, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		return nil, fmt.Errorf("please login")
	}

	d, err := env.Dynamo(ctx).GetDocNotificationPreference(currentUser.Id, obj.ID)
	if err != nil {
		return nil, err
	}

	return d.Preference, nil
}

// Screenshots is the resolver for the screenshots field.
func (r *documentResolver) Screenshots(ctx context.Context, obj *models.Document) (*model.DocumentScreenshots, error) {
	urls, err := rogue.GetLastScreenshotsURL(ctx, obj.ID)
	if err != nil {
		log.Warnf("missing screenshot: %s", err)
		return nil, nil
	}

	out := &model.DocumentScreenshots{
		LightURL: urls[1],
		DarkURL:  urls[0],
	}

	return out, nil
}

// BranchCopies is the resolver for the branchCopies field.
func (r *documentResolver) BranchCopies(ctx context.Context, obj *models.Document) ([]*models.Document, error) {
	documentID := obj.ID

	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	docAccessTbl := env.Query(ctx).DocumentAccess
	count, err := docAccessTbl.
		Where(docAccessTbl.DocumentID.Eq(documentID)).
		Where(docAccessTbl.UserID.Eq(currentUser.Id)).
		Where(docAccessTbl.AccessLevel.Eq("owner")).
		Count()
	if err != nil {
		return nil, err
	}

	if count == 0 {
		log.Errorf("current user is not the owner of the document")
		return nil, fmt.Errorf("unauthorized")
	}

	branches, err := document.GetBranchCopies(ctx, currentUser.Id, documentID)
	if err != nil {
		log.Errorf("error getting branches: %s", err)
		return nil, fmt.Errorf("sorry, we could not load your branches")
	}

	return branches, nil
}

// Access is the resolver for the access field.
func (r *documentResolver) Access(ctx context.Context, obj *models.Document) (string, error) {
	log := env.SLog(ctx)
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Error("error getting current user", "error", err)
		return "", fmt.Errorf("please login")
	}

	level, err := loaders.GetDocumentAccess(ctx, obj.ID, currentUser.Id)
	if err != nil {
		log.Error("error getting document access", "error", err)
		return "", fmt.Errorf("error getting document access: %s", err)
	}

	return level, nil
}

// CreateDocument is the resolver for the createDocument field.
func (r *mutationResolver) CreateDocument(ctx context.Context) (*models.Document, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	userTbl := env.Query(ctx).User
	user, err := userTbl.Where(userTbl.ID.Eq(currentUser.Id)).First()
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	doc, err := document.Create(ctx, user.ID)
	if err != nil {
		log.Errorf("error creating db document: %s", err)
		return nil, fmt.Errorf("sorry, we could not create your document")
	}

	return doc, nil
}

// CreateFolder is the resolver for the createFolder field.
func (r *mutationResolver) CreateFolder(ctx context.Context) (*models.Document, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	userTbl := env.Query(ctx).User
	user, err := userTbl.Where(userTbl.ID.Eq(currentUser.Id)).First()
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	folder, err := document.CreateFolder(ctx, user)
	if err != nil {
		log.Errorf("error creating db document: %s", err)
		return nil, fmt.Errorf("sorry, we could not create your folder")
	}

	return folder, nil
}

// CreateFlaggedVersion is the resolver for the createFlaggedVersion field.
func (r *mutationResolver) CreateFlaggedVersion(ctx context.Context, documentID string, input model.FlaggedVersionInput) (bool, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		return false, err
	}

	// Check if the document & they have access
	_, err = query.GetEditableDocumentForUser(env.Query(ctx), documentID, currentUser.Id)
	if err != nil {
		return false, err
	}

	event, err := env.Dynamo(ctx).GetTimelineEvent(documentID, input.UpdateID)
	if err != nil {
		return false, err
	}

	if event == nil {
		return false, fmt.Errorf("timeline event not found")
	}

	// check if the event is a Payload_Update
	update, ok := event.Event.Payload.(*models.TimelineEventPayload_Update)
	if !ok {
		return false, fmt.Errorf("event is not a Payload_Update")
	}

	//add a new document version
	docVersion := &models.DocumentVersion{
		Name:           input.Name,
		DocumentID:     documentID,
		ContentAddress: update.Update.EndingContentAddress,
		CreatedBy:      currentUser.Id,
		UpdatedBy:      currentUser.Id,
	}

	docVersionTbl := env.Query(ctx).DocumentVersion
	err = docVersionTbl.Create(docVersion)
	if err != nil {
		return false, err
	}

	event.Event.Payload.(*models.TimelineEventPayload_Update).Update.FlaggedVersionId = docVersion.ID

	// Update the timeline event
	err = timeline.UpdateTimelineEvent(ctx, event)
	if err != nil {
		return false, err
	}

	return true, nil
}

// EditFlaggedVersion is the resolver for the editFlaggedVersion field.
func (r *mutationResolver) EditFlaggedVersion(ctx context.Context, flaggedVersionID string, input model.FlaggedVersionInput) (bool, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		return false, err
	}

	docVersionTbl := env.Query(ctx).DocumentVersion
	docVersion, err := docVersionTbl.Where(docVersionTbl.ID.Eq(flaggedVersionID)).First()
	if err != nil {
		return false, err
	}

	// check document access
	_, err = query.GetEditableDocumentForUser(env.Query(ctx), docVersion.DocumentID, currentUser.Id)
	if err != nil {
		return false, err
	}

	docVersion.Name = input.Name

	err = docVersionTbl.Save(docVersion)
	if err != nil {
		return false, err
	}

	event, err := env.Dynamo(ctx).GetTimelineEvent(docVersion.DocumentID, input.UpdateID)
	if err != nil {
		return false, err
	}

	err = timeline.UpdateTimelineEvent(ctx, event)
	if err != nil {
		return false, err
	}

	return true, nil
}

// DeleteFlaggedVersion is the resolver for the deleteFlaggedVersion field.
func (r *mutationResolver) DeleteFlaggedVersion(ctx context.Context, flaggedVersionID string, timelineEventID string) (bool, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		return false, err
	}

	docVersionTbl := env.Query(ctx).DocumentVersion
	docVersion, err := docVersionTbl.Where(docVersionTbl.ID.Eq(flaggedVersionID)).First()
	if err != nil {
		return false, err
	}
	docId := docVersion.DocumentID

	// check document access
	_, err = query.GetEditableDocumentForUser(env.Query(ctx), docVersion.DocumentID, currentUser.Id)
	if err != nil {
		return false, err
	}

	_, err = docVersionTbl.Delete(docVersion)
	if err != nil {
		return false, err
	}

	event, err := env.Dynamo(ctx).GetTimelineEvent(docId, timelineEventID)
	if err != nil {
		return false, err
	}

	if event == nil || event.Event == nil || event.Event.Payload == nil {
		return false, fmt.Errorf("invalid timeline event structure")
	}

	update, ok := event.Event.Payload.(*models.TimelineEventPayload_Update)
	if !ok {
		return false, fmt.Errorf("unexpected payload type")
	}

	if update.Update == nil {
		return false, fmt.Errorf("invalid update structure")
	}

	update.Update.FlaggedVersionId = ""

	err = timeline.UpdateTimelineEvent(ctx, event)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UpdateDocument is the resolver for the updateDocument field.
func (r *mutationResolver) UpdateDocument(ctx context.Context, id string, input model.DocumentInput) (*models.Document, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	documentTbl := env.Query(ctx).Document
	docAccessTbl := env.Query(ctx).DocumentAccess

	doc, err := documentTbl.
		LeftJoin(docAccessTbl, documentTbl.ID.EqCol(docAccessTbl.DocumentID)).
		Where(docAccessTbl.UserID.Eq(currentUser.Id)).
		Where(docAccessTbl.AccessLevel.In("owner", "write")).
		Where(documentTbl.ID.Eq(id)).
		First()
	if err != nil {
		log.Errorf("error getting document: %s", stackerr.Wrap(err))
		return nil, fmt.Errorf("sorry, we could not load your document")
	}

	return document.UpdateDocument(ctx, doc, currentUser.Id, input.Title, input.IsPublic)
}

// DeleteDocument is the resolver for the deleteDocument field.
func (r *mutationResolver) DeleteDocument(ctx context.Context, id string, deleteChildren *bool) (*bool, error) {
	documentID := id
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	deleted := false
	docTbl := env.Query(ctx).Document
	docAccessTbl := env.Query(ctx).DocumentAccess

	// Check if the current user is the owner of the document
	count, err := docAccessTbl.
		Where(docAccessTbl.DocumentID.Eq(documentID)).
		Where(docAccessTbl.UserID.Eq(currentUser.Id)).
		Where(docAccessTbl.AccessLevel.Eq("owner")).
		Count()
	if err != nil {
		return &deleted, err
	}

	if count == 0 {
		log.Errorf("current user is not the owner of the document")
		return &deleted, fmt.Errorf("unauthorized")
	}

	// delete children first if requested
	if deleteChildren != nil && *deleteChildren {
		children, err := docTbl.Where(docTbl.FolderID.Eq(documentID)).Find()
		if err != nil {
			log.Errorf("[deleteDocument] error getting children: %s", err)
			return &deleted, err
		}
		for _, child := range children {
			_, err = r.DeleteDocument(ctx, child.ID, deleteChildren)
			if err != nil {
				log.Errorf("error deleting document: %s", err)
				return &deleted, fmt.Errorf("sorry, we could not delete your document")
			}
		}
	} else {
		_, err = docTbl.Where(docTbl.FolderID.Eq(documentID)).Update(docTbl.FolderID, nil)
		if err != nil {
			log.Errorf("error deleting children of document: %s", err)
			return &deleted, fmt.Errorf("sorry, we could not delete your document")
		}
	}

	// delete the branch copies first
	branches, err := document.GetBranchCopies(ctx, currentUser.Id, documentID)
	if err != nil {
		log.Errorf("error getting branches: %s", err)
		return &deleted, fmt.Errorf("sorry, we could not delete your document")
	}

	for _, branch := range branches {
		err = document.Delete(ctx, branch.ID)
		if err != nil {
			log.Errorf("error deleting branch %s for document %s: %s", branch.ID, documentID, err)
			return &deleted, fmt.Errorf("sorry, we could not delete your document")
		}
	}

	// delete the document
	err = document.Delete(ctx, documentID)
	if err != nil {
		log.Errorf("error deleting document: %s", err)
		return &deleted, fmt.Errorf("sorry, we could not delete your document")
	}

	deleted = true
	return &deleted, nil
}

// SoftDeleteDocument is the resolver for the softDeleteDocument field.
func (r *mutationResolver) SoftDeleteDocument(ctx context.Context, id string) (*bool, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	deleted := false
	documentTbl := env.Query(ctx).Document
	docAccessTbl := env.Query(ctx).DocumentAccess

	doc, err := documentTbl.
		LeftJoin(docAccessTbl, documentTbl.ID.EqCol(docAccessTbl.DocumentID)).
		Where(docAccessTbl.UserID.Eq(currentUser.Id)).
		Where(docAccessTbl.AccessLevel.In("owner")).
		Where(documentTbl.ID.Eq(id)).
		First()
	if err != nil {
		log.Errorf("error getting document: %s", stackerr.Wrap(err))
		return &deleted, fmt.Errorf("sorry, we could not load your document")
	}

	doc.DeletedAt.Time = time.Now()
	doc.DeletedAt.Valid = true

	err = documentTbl.Save(doc)
	if err != nil {
		log.Errorf("error soft deleting document: %s", err)
		return &deleted, fmt.Errorf("sorry, we could not soft delete your document")
	}

	deleted = true
	return &deleted, nil
}

// CopyDocument is the resolver for the copyDocument field.
func (r *mutationResolver) CopyDocument(ctx context.Context, id string, isBranch *bool, address *string) (*models.Document, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	srcDoc, err := query.GetReadableDocumentForUser(env.Query(ctx), id, currentUser.Id)
	if err != nil {
		log.Errorf("error getting document: %s", stackerr.Wrap(err))
		return nil, fmt.Errorf("sorry, you cannot duplicate this document")
	}

	s3 := env.S3(ctx)
	redis := env.Redis(ctx)
	query := env.Query(ctx)
	ds := rogue.NewDocStore(s3, query, redis)

	copyDoc := &models.Document{IsPublic: srcDoc.IsPublic}
	if isBranch != nil && *isBranch {
		copyDoc.Title = fmt.Sprintf("%s (branch)", srcDoc.Title)
		copyDoc.ParentID = &srcDoc.ID
		copyDoc.RootParentID = srcDoc.RootParentID
	} else {
		copyDoc.Title = fmt.Sprintf("%s (copy)", srcDoc.Title)
	}

	dupDoc, err := document.CreateCustom(ctx, currentUser.Id, copyDoc)
	if err != nil {
		log.Errorf("error creating db document: %v", err)
		return nil, fmt.Errorf("sorry, we could not duplicate your document")
	}

	err = ds.DuplicateDoc(ctx, id, dupDoc.ID, address)
	if err != nil {
		log.Errorf("error duplicating document: %v", err)
		return nil, fmt.Errorf("sorry, we could not duplicate your document")
	}

	return dupDoc, nil
}

// MoveDocument is the resolver for the moveDocument field.
func (r *mutationResolver) MoveDocument(ctx context.Context, id string, folderID *string) (*models.Document, error) {
	log := env.Log(ctx)
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	q := env.Query(ctx)
	doc, err := query.GetOwnedDocumentForUser(q, id, currentUser.Id)
	if err != nil {
		log.Errorf("error getting document: %s", stackerr.Wrap(err))
		return nil, fmt.Errorf("sorry, you cannot move this document")
	}

	doc.FolderID = folderID
	err = q.Document.Save(doc)
	if err != nil {
		log.Errorf("error saving document: %s", stackerr.Wrap(err))
		return nil, fmt.Errorf("sorry, we could not move your document")
	}

	return doc, nil
}

// UpdateDocumentPreference is the resolver for the updateDocumentPreference field.
func (r *mutationResolver) UpdateDocumentPreference(ctx context.Context, id string, input model.DocumentPreferenceInput) (*models.DocumentPreference, error) {
	log := env.Log(ctx)
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	pref := &models.DocumentPreference{
		EnableFirstOpenNotifications:  input.EnableFirstOpenNotifications,
		EnableAllCommentNotifications: input.EnableAllCommentNotifications,
		EnableDmNotifications:         input.EnableDMNotifications,
		EnableMentionNotifications:    input.EnableMentionNotifications,
	}

	d := &dynamo.DocPreference{
		UserID:     currentUser.Id,
		DocID:      id,
		Preference: pref,
	}

	err = env.Dynamo(ctx).UpsertDocNotificationPreference(d)
	if err != nil {
		log.Errorf("error updating document preference: %s", err)
		return nil, fmt.Errorf("sorry, we could not update your document preference")
	}

	err = pubsub.PublishDocument(ctx, id)
	if err != nil {
		log.Errorf("error publishing document: %s", err)
	}

	return pref, nil
}

// Documents is the resolver for the documents field.
func (r *queryResolver) Documents(ctx context.Context, limit *int, offset *int) (*model.DocumentConnection, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	if limit == nil {
		limit = &DefaultDocumentLimit
	}
	if offset == nil {
		offset = &DefaultOffset
	}

	documents, err := document.GetAllDocuments(ctx, currentUser.Id, *limit, *offset)
	if err != nil {
		log.Errorf("error getting documents: %s", err)
		return nil, fmt.Errorf("sorry, we could not load your documents")
	}

	totalCount := len(documents)

	edges := make([]*model.DocumentEdge, len(documents))
	for i, document := range documents {
		edges[i] = &model.DocumentEdge{
			Node:   document,
			Cursor: document.ID,
		}
	}

	connection := &model.DocumentConnection{
		TotalCount: int(totalCount),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			HasNextPage: totalCount == *limit,
		},
	}

	return connection, nil
}

// BaseDocuments is the resolver for the baseDocuments field.
func (r *queryResolver) BaseDocuments(ctx context.Context, limit *int, offset *int) (*model.DocumentConnection, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	if limit == nil {
		limit = &DefaultDocumentLimit
	}
	if offset == nil {
		offset = &DefaultOffset
	}

	documents, err := document.GetRootDocuments(ctx, nil, currentUser.Id, *limit, *offset)
	if err != nil {
		log.Errorf("error getting documents: %s", err)
		return nil, fmt.Errorf("sorry, we could not load your documents")
	}

	totalCount := len(documents)

	edges := make([]*model.DocumentEdge, len(documents))
	for i, document := range documents {
		edges[i] = &model.DocumentEdge{
			Node:   document,
			Cursor: document.ID,
		}
	}

	connection := &model.DocumentConnection{
		TotalCount: int(totalCount),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			HasNextPage: totalCount == *limit,
		},
	}

	return connection, nil
}

// SharedDocuments is the resolver for the sharedDocuments field.
func (r *queryResolver) SharedDocuments(ctx context.Context, limit *int, offset *int) (*model.DocumentConnection, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	if limit == nil {
		limit = &DefaultDocumentLimit
	}
	if offset == nil {
		offset = &DefaultOffset
	}

	documents, err := document.GetSharedDocuments(ctx, currentUser.Id, *limit, *offset)
	if err != nil {
		log.Errorf("error getting documents: %s", err)
		return nil, fmt.Errorf("sorry, we could not load your documents")
	}

	totalCount := len(documents)

	edges := make([]*model.DocumentEdge, len(documents))
	for i, document := range documents {
		edges[i] = &model.DocumentEdge{
			Node:   document,
			Cursor: document.ID,
		}
	}

	connection := &model.DocumentConnection{
		TotalCount: int(totalCount),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			HasNextPage: totalCount == *limit,
		},
	}

	return connection, nil
}

// FolderDocuments is the resolver for the folderDocuments field.
func (r *queryResolver) FolderDocuments(ctx context.Context, folderID string, limit *int, offset *int) (*model.DocumentConnection, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	if limit == nil {
		limit = &DefaultDocumentLimit
	}
	if offset == nil {
		offset = &DefaultOffset
	}

	documents, err := document.GetRootDocuments(ctx, &folderID, currentUser.Id, *limit, *offset)
	if err != nil {
		log.Errorf("error getting documents: %s", err)
		return nil, fmt.Errorf("sorry, we could not load your documents")
	}

	totalCount := len(documents)

	edges := make([]*model.DocumentEdge, len(documents))
	for i, document := range documents {
		edges[i] = &model.DocumentEdge{
			Node:   document,
			Cursor: document.ID,
		}
	}

	connection := &model.DocumentConnection{
		TotalCount: int(totalCount),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			HasNextPage: totalCount == *limit,
		},
	}

	return connection, nil
}

// SearchDocuments is the resolver for the searchDocuments field.
func (r *queryResolver) SearchDocuments(ctx context.Context, query string, limit *int, offset *int) (*model.DocumentConnection, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	if limit == nil {
		limit = &DefaultDocumentLimit
	}
	if offset == nil {
		offset = &DefaultOffset
	}

	documents, err := document.SearchRootDocuments(ctx, query, currentUser.Id, *limit, *offset)
	if err != nil {
		log.Errorf("error getting documents: %s", err)
		return nil, fmt.Errorf("sorry, we could not load your documents")
	}

	totalCount := len(documents)

	edges := make([]*model.DocumentEdge, len(documents))
	for i, document := range documents {
		edges[i] = &model.DocumentEdge{
			Node:   document,
			Cursor: document.ID,
		}
	}

	connection := &model.DocumentConnection{
		TotalCount: int(totalCount),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			HasNextPage: totalCount == *limit,
		},
	}

	return connection, nil
}

// Document is the resolver for the document field.
func (r *queryResolver) Document(ctx context.Context, id string) (*models.Document, error) {
	log := env.Log(ctx)
	currentUser, err := env.UserClaim(ctx)
	if err != nil || currentUser == nil {
		return nil, fmt.Errorf("please login")
	}

	doc, err := query.GetReadableDocumentForUser(env.Query(ctx), id, currentUser.Id)
	if err != nil {
		log.Errorf("error getting document: %s", stackerr.Wrap(err))
		return nil, fmt.Errorf("sorry, we could not load your document")
	}
	log.Info("got document", "document", doc)

	return doc, nil
}

// Branches is the resolver for the branches field.
func (r *queryResolver) Branches(ctx context.Context, id string) ([]*models.Document, error) {
	documentID := id

	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	docAccessTbl := env.Query(ctx).DocumentAccess
	count, err := docAccessTbl.
		Where(docAccessTbl.DocumentID.Eq(documentID)).
		Where(docAccessTbl.UserID.Eq(currentUser.Id)).
		Where(docAccessTbl.AccessLevel.Eq("owner")).
		Count()
	if err != nil {
		return nil, err
	}

	if count == 0 {
		log.Errorf("current user is not the owner of the document")
		return nil, fmt.Errorf("unauthorized")
	}

	branches, err := document.GetBranchCopies(ctx, currentUser.Id, documentID)
	if err != nil {
		log.Errorf("error getting branches: %s", err)
		return nil, fmt.Errorf("sorry, we could not load your branches")
	}

	return branches, nil
}

// DocumentInserted is the resolver for the documentInserted field.
func (r *subscriptionResolver) DocumentInserted(ctx context.Context, userID string) (<-chan *models.Document, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		return nil, fmt.Errorf("please login")
	}

	ch := make(chan *models.Document)

	go pubsub.ListenForNewDocuments(ctx, ch, currentUser.Id)

	return ch, nil
}

// DocumentUpdated is the resolver for the documentUpdated field.
func (r *subscriptionResolver) DocumentUpdated(ctx context.Context, documentID string) (<-chan *models.Document, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		return nil, fmt.Errorf("please login")
	}

	ch := make(chan *models.Document)

	go pubsub.ListenForDocumentUpdates(ctx, ch, documentID, currentUser.Id)

	return ch, nil
}

// Document returns DocumentResolver implementation.
func (r *Resolver) Document() DocumentResolver { return &documentResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type documentResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
