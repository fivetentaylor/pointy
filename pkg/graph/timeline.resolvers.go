package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"context"
	"fmt"
	"log/slog"
	"time"

	"github.com/charmbracelet/log"
	"github.com/google/uuid"
	"github.com/teamreviso/code/pkg/background/wire"
	"github.com/teamreviso/code/pkg/env"
	"github.com/teamreviso/code/pkg/graph/loaders"
	"github.com/teamreviso/code/pkg/graph/model"
	"github.com/teamreviso/code/pkg/models"
	"github.com/teamreviso/code/pkg/query"
	"github.com/teamreviso/code/pkg/service/timeline"
	"github.com/teamreviso/code/pkg/storage/dynamo"
	"github.com/teamreviso/code/pkg/utils"
)

// CreateTimelineMessage is the resolver for the createTimelineMessage field.
func (r *mutationResolver) CreateTimelineMessage(ctx context.Context, documentID string, input model.TimelineMessageInput) (*dynamo.TimelineEvent, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		return nil, err
	}

	// Check if the document & they have access
	_, err = query.GetEditableDocumentForUser(env.Query(ctx), documentID, currentUser.Id)
	if err != nil {
		return nil, err
	}

	event := &dynamo.TimelineEvent{
		DocID:    documentID,
		UserID:   currentUser.Id,
		AuthorID: input.AuthorID,
		Event: &models.TimelineEventPayload{
			Payload: &models.TimelineEventPayload_Message{
				Message: &models.TimelineMessageV1{
					Content:        input.Content,
					ContentAddress: input.ContentAddress,
				},
			},
		},
	}

	if input.StartID != nil {
		event.Event.GetMessage().SelectionStartId = *input.StartID
	}

	if input.EndID != nil {
		event.Event.GetMessage().SelectionEndId = *input.EndID
	}

	if input.ReplyTo != nil {
		event.ReplyToID = *input.ReplyTo
	}

	if input.SelectionMarkdown != nil {
		event.Event.GetMessage().SelectionMarkdown = *input.SelectionMarkdown
	}

	err = timeline.CreateTimelineEvent(ctx, event)
	if err != nil {
		return nil, err
	}

	return event, nil
}

// ForceTimelineUpdateSummary is the resolver for the forceTimelineUpdateSummary field.
func (r *mutationResolver) ForceTimelineUpdateSummary(ctx context.Context, documentID string, userID string) (bool, error) {
	log := env.Log(ctx)
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return false, err
	}

	_, err = query.GetEditableDocumentForUser(env.Query(ctx), documentID, currentUser.Id)
	if err != nil {
		log.Errorf("error getting editable document: %s", err)
		return false, err
	}

	_, err = env.Background(ctx).Enqueue(ctx, &wire.SummarizeSession{
		SessionId: uuid.NewString(),
		DocId:     documentID,
		UserId:    userID,
	})
	if err != nil {
		log.Errorf("error enqueueing summarize session: %s", err)
		return false, err
	}

	return true, nil
}

// EditTimelineMessage is the resolver for the editTimelineMessage field.
func (r *mutationResolver) EditTimelineMessage(ctx context.Context, documentID string, messageID string, input model.EditTimelineMessageInput) (*dynamo.TimelineEvent, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		return nil, err
	}

	// Check if the document & they have access
	_, err = query.GetEditableDocumentForUser(env.Query(ctx), documentID, currentUser.Id)
	if err != nil {
		return nil, err
	}

	// Fetch the existing timeline event
	event, err := env.Dynamo(ctx).GetTimelineEvent(documentID, messageID)
	if err != nil {
		return nil, err
	}

	if event == nil {
		return nil, fmt.Errorf("timeline event not found")
	}

	// Check if the current user is the author of the message
	if event.UserID != currentUser.Id {
		return nil, fmt.Errorf("you don't have permission to edit this message")
	}

	// Update the message content
	message := event.Event.GetMessage()
	if message == nil {
		return nil, fmt.Errorf("invalid event type")
	}

	message.Content = input.Content

	// Update other fields if provided
	if input.ContentAddress != nil {
		message.ContentAddress = *input.ContentAddress
	}
	if input.StartID != nil {
		message.SelectionStartId = *input.StartID
	}
	if input.EndID != nil {
		message.SelectionEndId = *input.EndID
	}
	if input.SelectionMarkdown != nil {
		message.SelectionMarkdown = *input.SelectionMarkdown
	}

	// Update the timeline event
	err = timeline.UpdateTimelineEvent(ctx, event)
	if err != nil {
		return nil, err
	}

	return event, nil
}

// ResolveTimelineMessage is the resolver for the resolveTimelineMessage field.
func (r *mutationResolver) UpdateMessageResolution(ctx context.Context, documentID string, messageID string, input model.UpdateMessageResolutionInput) (*dynamo.TimelineEvent, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		return nil, err
	}

	// Check if the document & they have access
	_, err = query.GetEditableDocumentForUser(env.Query(ctx), documentID, currentUser.Id)
	if err != nil {
		return nil, err
	}

	event := &dynamo.TimelineEvent{
		DocID:    documentID,
		UserID:   currentUser.Id,
		AuthorID: input.AuthorID,
		Event: &models.TimelineEventPayload{
			Payload: &models.TimelineEventPayload_Resolution{
				Resolution: &models.TimelineMessageResolutionV1{
					Resolved: input.Resolved,
				},
			},
		},
	}

	event.ReplyToID = messageID

	err = timeline.CreateTimelineEvent(ctx, event)
	if err != nil {
		return nil, err
	}

	if input.Resolved {
		_, err = env.Background(ctx).Enqueue(ctx, &wire.SummarizeCommentThread{
			DocId:         documentID,
			EventId:       event.EventID,
			ThreadEventId: event.ReplyToID,
		})
		if err != nil {
			log.Errorf("error enqueuing summarize comment thread: %s", err)
		}
	}

	return event, nil
}

// EditMessageResolutionSummary is the resolver for the editMessageResolutionSummary field.
func (r *mutationResolver) EditMessageResolutionSummary(ctx context.Context, documentID string, messageID string, summary string) (*dynamo.TimelineEvent, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		return nil, err
	}

	// Check if the document exists and the user has access
	_, err = query.GetEditableDocumentForUser(env.Query(ctx), documentID, currentUser.Id)
	if err != nil {
		return nil, err
	}

	event, err := env.Dynamo(ctx).GetTimelineEvent(documentID, messageID)
	if err != nil {
		return nil, err
	}

	if event == nil {
		return nil, fmt.Errorf("timeline event not found")
	}

	if event.Event.GetResolution() == nil {
		return nil, fmt.Errorf("event is not a resolution")
	}

	event.Event.GetResolution().ResolutionSummary = summary

	err = timeline.UpdateTimelineEvent(ctx, event)
	if err != nil {
		return nil, err
	}

	return event, nil
}

// EditTimelineUpdateSummary is the resolver for the editTimelineUpdateSummary field.
func (r *mutationResolver) EditTimelineUpdateSummary(ctx context.Context, documentID string, updateID string, summary string) (*dynamo.TimelineEvent, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		return nil, err
	}

	// Check if the document exists and the user has access
	_, err = query.GetEditableDocumentForUser(env.Query(ctx), documentID, currentUser.Id)
	if err != nil {
		return nil, err
	}

	// Fetch the existing timeline event
	event, err := env.Dynamo(ctx).GetTimelineEvent(documentID, updateID)
	if err != nil {
		return nil, err
	}

	if event == nil {
		return nil, fmt.Errorf("timeline event not found")
	}

	// Update the timeline event
	event.Event.GetUpdate().Content = summary

	err = timeline.UpdateTimelineEvent(ctx, event)
	if err != nil {
		return nil, err
	}

	return event, nil
}

// DeleteTimelineMessage is the resolver for the deleteTimelineMessage field.
func (r *mutationResolver) DeleteTimelineMessage(ctx context.Context, documentID string, messageID string) (bool, error) {
	log := env.Log(ctx)
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return false, err
	}

	// Check if the document exists and the user has access
	_, err = query.GetEditableDocumentForUser(env.Query(ctx), documentID, currentUser.Id)
	if err != nil {
		log.Errorf("error getting editable document: %s", err)
		return false, err
	}

	// Fetch the existing timeline event
	event, err := env.Dynamo(ctx).GetTimelineEvent(documentID, messageID)
	if err != nil {
		log.Errorf("error fetching timeline event: %s", err)
		return false, err
	}

	if event == nil {
		return false, fmt.Errorf("timeline event not found")
	}

	// Check if the current user is the author of the message
	if event.UserID != currentUser.Id {
		return false, fmt.Errorf("you don't have permission to delete this message")
	}

	// Delete the timeline event
	err = timeline.DeleteTimelineEvent(ctx, event)
	if err != nil {
		log.Errorf("error deleting timeline event: %s", err)
		return false, err
	}

	return true, nil
}

// GetDocumentTimeline is the resolver for the getDocumentTimeline field.
func (r *queryResolver) GetDocumentTimeline(ctx context.Context, documentID string, filter *model.TimelineEventFilter) ([]*dynamo.TimelineEvent, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		return nil, err
	}

	// Check if the document & they have access
	_, err = query.GetEditableDocumentForUser(env.Query(ctx), documentID, currentUser.Id)
	if err != nil {
		return nil, err
	}

	events, err := env.Dynamo(ctx).GetDocumentTimeline(documentID)
	if err != nil {
		return nil, err
	}

	if filter == nil || *filter == model.TimelineEventFilterAll {
		return events, nil
	}

	var out []*dynamo.TimelineEvent
	if *filter == model.TimelineEventFilterComments {
		for _, event := range events {
			_, ok := event.Event.Payload.(*models.TimelineEventPayload_Message)
			if ok {
				out = append(out, event)
			}
		}
	} else if *filter == model.TimelineEventFilterEdits {
		for _, event := range events {
			_, ok := event.Event.Payload.(*models.TimelineEventPayload_Update)
			if ok {
				out = append(out, event)
			}
		}
	}

	return out, nil
}

// TimelineEventInserted is the resolver for the timelineEventInserted field.
func (r *subscriptionResolver) TimelineEventInserted(ctx context.Context, documentID string) (<-chan *dynamo.TimelineEvent, error) {
	log := env.Log(ctx)

	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	// Check if the document & they have access
	_, err = query.GetEditableDocumentForUser(env.Query(ctx), documentID, currentUser.Id)
	if err != nil {
		return nil, err
	}

	ch := make(chan *dynamo.TimelineEvent)
	go timeline.ListenForTimelineEvents(ctx, ch, documentID, timeline.EventTypeInsert)
	return ch, nil
}

// TimelineEventUpdated is the resolver for the timelineEventUpdated field.
func (r *subscriptionResolver) TimelineEventUpdated(ctx context.Context, documentID string) (<-chan *dynamo.TimelineEvent, error) {
	log := env.Log(ctx)

	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	// Check if the document & they have access
	_, err = query.GetEditableDocumentForUser(env.Query(ctx), documentID, currentUser.Id)
	if err != nil {
		return nil, err
	}

	ch := make(chan *dynamo.TimelineEvent)
	go timeline.ListenForTimelineEvents(ctx, ch, documentID, timeline.EventTypeUpdate)
	return ch, nil
}

// TimelineEventDeleted is the resolver for the timelineEventDeleted field.
func (r *subscriptionResolver) TimelineEventDeleted(ctx context.Context, documentID string) (<-chan *dynamo.TimelineEvent, error) {
	log := env.Log(ctx)

	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("please login")
	}

	// Check if the document & they have access
	_, err = query.GetEditableDocumentForUser(env.Query(ctx), documentID, currentUser.Id)
	if err != nil {
		return nil, err
	}

	ch := make(chan *dynamo.TimelineEvent)
	go timeline.ListenForTimelineEvents(ctx, ch, documentID, timeline.EventTypeDelete)
	return ch, nil
}

// Replies is the resolver for the replies field.
func (r *tLMessageV1Resolver) Replies(ctx context.Context, obj *model.TLMessageV1) ([]*dynamo.TimelineEvent, error) {
	return env.Dynamo(ctx).GetDocumentTimelineReplies(obj.DocumentID, obj.EventID)
}

// ID is the resolver for the id field.
func (r *timelineEventResolver) ID(ctx context.Context, obj *dynamo.TimelineEvent) (string, error) {
	return obj.EventID, nil
}

// DocumentID is the resolver for the documentId field.
func (r *timelineEventResolver) DocumentID(ctx context.Context, obj *dynamo.TimelineEvent) (string, error) {
	return obj.DocID, nil
}

// ReplyTo is the resolver for the replyTo field.
func (r *timelineEventResolver) ReplyTo(ctx context.Context, obj *dynamo.TimelineEvent) (string, error) {
	return obj.ReplyToID, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *timelineEventResolver) CreatedAt(ctx context.Context, obj *dynamo.TimelineEvent) (*time.Time, error) {
	return utils.UnixNanoToTime(obj.CreatedAt), nil
}

// User is the resolver for the user field.
func (r *timelineEventResolver) User(ctx context.Context, obj *dynamo.TimelineEvent) (*models.User, error) {
	return loaders.GetUser(ctx, obj.UserID)
}

// Event is the resolver for the event field.
func (r *timelineEventResolver) Event(ctx context.Context, obj *dynamo.TimelineEvent) (model.TLEventPayload, error) {
	log := env.SLog(ctx)
	switch v := obj.Event.Payload.(type) {
	case *models.TimelineEventPayload_Marker:
		return model.TLMarkerV1{
			Title: v.Marker.Title,
		}, nil
	case *models.TimelineEventPayload_Update:
		update := model.TLUpdateV1{
			EventID:                obj.EventID,
			Title:                  v.Update.Title,
			Content:                v.Update.Content,
			StartingContentAddress: v.Update.StartingContentAddress,
			EndingContentAddress:   v.Update.EndingContentAddress,
		}

		hydratedUpdate, err := timeline.HydrateFlaggedVersion(ctx, &update, v.Update)
		if err != nil {
			log.Error("error hydrating flagged version", slog.Any("error", err))
		} else {
			update = *hydratedUpdate
		}

		switch v.Update.State {
		case models.UpdateState_SUMMARIZING_STATE:
			update.State = model.TLUpdateStateSummarizing
		case models.UpdateState_COMPLETE_STATE:
			update.State = model.TLUpdateStateComplete
		default:
			update.State = model.TLUpdateStateComplete
		}

		return update, nil
	case *models.TimelineEventPayload_Message:
		tlMessage := v.Message

		msg := model.TLMessageV1{
			Content:           tlMessage.Content,
			ContentAddress:    tlMessage.ContentAddress,
			SelectionStartID:  tlMessage.SelectionStartId,
			SelectionEndID:    tlMessage.SelectionEndId,
			SelectionMarkdown: tlMessage.SelectionMarkdown,

			// Adding DocumentID and EventID here so it can be used in the Replies resolver
			DocumentID: obj.DocID,
			EventID:    obj.EventID,
		}

		log.Info("hydrating mentions", "msg", msg)
		_, err := timeline.HydrateMentions(ctx, &msg, tlMessage.MentionedUserIds)
		if err != nil {
			log.Error("error hydrating mentions", "error", err)
			return nil, fmt.Errorf("error hydrating mentions: %s", err)
		}

		return msg, nil
	case *models.TimelineEventPayload_Join:
		return model.TLJoinV1{
			Action: v.Join.Action,
		}, nil
	case *models.TimelineEventPayload_AttributeChange:
		return model.TLAttributeChangeV1{
			Attribute: v.AttributeChange.Attribute,
			OldValue:  v.AttributeChange.OldValue,
			NewValue:  v.AttributeChange.NewValue,
		}, nil
	case *models.TimelineEventPayload_AccessChange:
		return model.TLAccessChangeV1{
			Action:          v.AccessChange.Action.String(),
			UserIdentifiers: v.AccessChange.UserIdentifiers,
		}, nil
	case *models.TimelineEventPayload_Resolution:
		return model.TLMessageResolutionV1{
			EventID:           obj.EventID,
			Resolved:          v.Resolution.Resolved,
			ResolutionSummary: v.Resolution.ResolutionSummary,
		}, nil
	case *models.TimelineEventPayload_Paste:
		return model.TLPasteV1{
			ContentAddressBefore: v.Paste.ContentAddressBefore,
			ContentAddressAfter:  v.Paste.ContentAddressAfter,
		}, nil
	default:
		log.Error("unknown payload type")
		return model.TLEmpty{
			Placeholder: "unknown payload type: " + fmt.Sprint(v),
		}, nil
	}
}

// TLMessageV1 returns TLMessageV1Resolver implementation.
func (r *Resolver) TLMessageV1() TLMessageV1Resolver { return &tLMessageV1Resolver{r} }

// TimelineEvent returns TimelineEventResolver implementation.
func (r *Resolver) TimelineEvent() TimelineEventResolver { return &timelineEventResolver{r} }

type tLMessageV1Resolver struct{ *Resolver }
type timelineEventResolver struct{ *Resolver }
