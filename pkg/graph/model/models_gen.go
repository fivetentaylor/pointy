// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/fivetentaylor/pointy/pkg/models"
	"github.com/fivetentaylor/pointy/pkg/storage/dynamo"
)

type AttachmentValue interface {
	IsAttachmentValue()
}

type NotificationPayloadValue interface {
	IsNotificationPayloadValue()
}

type TLEventPayload interface {
	IsTLEventPayload()
}

type AiContent struct {
	Notes             *string `json:"notes,omitempty"`
	ConcludingMessage *string `json:"concludingMessage,omitempty"`
	Feedback          *string `json:"feedback,omitempty"`
}

type AttachedRevisoDocument struct {
	ID    string `json:"id"`
	Title string `json:"title"`
}

func (AttachedRevisoDocument) IsAttachmentValue() {}

type AttachmentContent struct {
	Text string `json:"text"`
	Role string `json:"role"`
}

func (AttachmentContent) IsAttachmentValue() {}

type AttachmentError struct {
	Title string `json:"title"`
	Text  string `json:"text"`
	Error string `json:"error"`
}

func (AttachmentError) IsAttachmentValue() {}

type AttachmentFile struct {
	ID          string `json:"id"`
	Filename    string `json:"filename"`
	ContentType string `json:"contentType"`
}

func (AttachmentFile) IsAttachmentValue() {}

type AttachmentInput struct {
	ID          string              `json:"id"`
	Type        AttachmentInputType `json:"type"`
	Name        string              `json:"name"`
	ContentType *string             `json:"contentType,omitempty"`
}

type BillingPortalSession struct {
	URL string `json:"url"`
}

type Chain struct {
	ID       string            `json:"id"`
	Messages []*dynamo.Message `json:"messages"`
}

type Checkout struct {
	URL string `json:"url"`
}

type CommentNotificationPayloadValue struct {
	CommentType CommentNotificationType `json:"commentType"`
	DocumentID  string                  `json:"documentId"`
	ChannelID   string                  `json:"channelId"`
	ContainerID string                  `json:"containerId"`
	MessageID   string                  `json:"messageId"`
	AuthorID    string                  `json:"authorId"`
	Author      *models.User            `json:"author"`
	Message     *dynamo.Message         `json:"message"`
}

func (CommentNotificationPayloadValue) IsNotificationPayloadValue() {}

type ContentAddress struct {
	ID         string `json:"id"`
	DocumentID string `json:"documentId"`
	Payload    string `json:"payload"`
}

type DocumentConnection struct {
	TotalCount int             `json:"totalCount"`
	Edges      []*DocumentEdge `json:"edges"`
	PageInfo   *PageInfo       `json:"pageInfo"`
}

type DocumentEdge struct {
	Node   *models.Document `json:"node"`
	Cursor string           `json:"cursor"`
}

type DocumentInput struct {
	Title    *string `json:"title,omitempty"`
	IsPublic *bool   `json:"isPublic,omitempty"`
}

type DocumentPreferenceInput struct {
	EnableFirstOpenNotifications  bool `json:"enableFirstOpenNotifications"`
	EnableMentionNotifications    bool `json:"enableMentionNotifications"`
	EnableDMNotifications         bool `json:"enableDMNotifications"`
	EnableAllCommentNotifications bool `json:"enableAllCommentNotifications"`
}

type DocumentScreenshots struct {
	LightURL string `json:"lightUrl"`
	DarkURL  string `json:"darkUrl"`
}

type EditTimelineMessageInput struct {
	Content           string  `json:"content"`
	ContentAddress    *string `json:"contentAddress,omitempty"`
	StartID           *string `json:"startID,omitempty"`
	EndID             *string `json:"endID,omitempty"`
	SelectionMarkdown *string `json:"selectionMarkdown,omitempty"`
}

type FlaggedVersionInput struct {
	Name     string `json:"name"`
	UpdateID string `json:"updateID"`
}

type Image struct {
	ID        string    `json:"id"`
	DocID     string    `json:"docId"`
	MimeType  string    `json:"mimeType"`
	CreatedAt time.Time `json:"createdAt"`
	URL       string    `json:"url"`
	Status    Status    `json:"status"`
	Error     *string   `json:"error,omitempty"`
}

type MessageInput struct {
	ReplyTo         *string            `json:"replyTo,omitempty"`
	AuthorID        string             `json:"authorId"`
	Content         string             `json:"content"`
	AllowDraftEdits bool               `json:"allowDraftEdits"`
	Llm             *MsgLlm            `json:"llm,omitempty"`
	ContentAddress  string             `json:"contentAddress"`
	Selection       *SelectionInput    `json:"selection,omitempty"`
	Attachments     []*AttachmentInput `json:"attachments,omitempty"`
}

type MessageUpdateInput struct {
	ID      string `json:"id"`
	Content string `json:"content"`
}

type MsgMetadata struct {
	AllowDraftEdits              bool                  `json:"allowDraftEdits"`
	ContentAddress               string                `json:"contentAddress"`
	Llm                          MsgLlm                `json:"llm"`
	RevisionStatus               MessageRevisionStatus `json:"revisionStatus"`
	ContentAddressBefore         string                `json:"contentAddressBefore"`
	ContentAddressAfter          string                `json:"contentAddressAfter"`
	ContentAddressAfterTimestamp *time.Time            `json:"contentAddressAfterTimestamp,omitempty"`
}

type MutationResponse struct {
	ID string `json:"id"`
}

type NotificationConnection struct {
	Edges []*dynamo.Notification `json:"edges"`
}

type PageInfo struct {
	HasNextPage bool `json:"hasNextPage"`
}

type Revision struct {
	Start                string  `json:"start"`
	End                  string  `json:"end"`
	Updated              string  `json:"updated"`
	MarshalledOperations string  `json:"marshalledOperations"`
	FollowUps            *string `json:"followUps,omitempty"`
	Explanation          *string `json:"explanation,omitempty"`
	BeforeAddress        *string `json:"beforeAddress,omitempty"`
	AfterAddress         *string `json:"afterAddress,omitempty"`
	AppliedOps           *string `json:"appliedOps,omitempty"`
}

func (Revision) IsAttachmentValue() {}

type Selection struct {
	ID      string `json:"id"`
	Start   string `json:"start"`
	End     string `json:"end"`
	Content string `json:"content"`
}

func (Selection) IsAttachmentValue() {}

type SelectionInput struct {
	Start   string `json:"start"`
	End     string `json:"end"`
	Content string `json:"content"`
}

type SignedImageURL struct {
	URL       string    `json:"url"`
	ExpiresAt time.Time `json:"expiresAt"`
}

type Suggestion struct {
	Content string `json:"content"`
}

func (Suggestion) IsAttachmentValue() {}

type TLAccessChangeV1 struct {
	Action          string   `json:"action"`
	UserIdentifiers []string `json:"userIdentifiers"`
}

func (TLAccessChangeV1) IsTLEventPayload() {}

type TLAttributeChangeV1 struct {
	Attribute string `json:"attribute"`
	OldValue  string `json:"oldValue"`
	NewValue  string `json:"newValue"`
}

func (TLAttributeChangeV1) IsTLEventPayload() {}

type TLEmpty struct {
	Placeholder string `json:"placeholder"`
}

func (TLEmpty) IsTLEventPayload() {}

type TLJoinV1 struct {
	Action string `json:"action"`
}

func (TLJoinV1) IsTLEventPayload() {}

type TLMarkerV1 struct {
	Title string `json:"title"`
}

func (TLMarkerV1) IsTLEventPayload() {}

type TLMessageResolutionV1 struct {
	EventID           string `json:"eventId"`
	Resolved          bool   `json:"resolved"`
	ResolutionSummary string `json:"resolutionSummary"`
}

func (TLMessageResolutionV1) IsTLEventPayload() {}

type TLMessageV1 struct {
	Content           string                  `json:"content"`
	SelectionStartID  string                  `json:"selectionStartId"`
	SelectionEndID    string                  `json:"selectionEndId"`
	SelectionMarkdown string                  `json:"selectionMarkdown"`
	ContentAddress    string                  `json:"contentAddress"`
	DocumentID        string                  `json:"documentId"`
	EventID           string                  `json:"eventId"`
	Replies           []*dynamo.TimelineEvent `json:"replies"`
}

func (TLMessageV1) IsTLEventPayload() {}

type TLPasteV1 struct {
	ContentAddressBefore string `json:"contentAddressBefore"`
	ContentAddressAfter  string `json:"contentAddressAfter"`
}

func (TLPasteV1) IsTLEventPayload() {}

type TLUpdateV1 struct {
	EventID                 string        `json:"eventId"`
	Title                   string        `json:"title"`
	Content                 string        `json:"content"`
	StartingContentAddress  string        `json:"startingContentAddress"`
	EndingContentAddress    string        `json:"endingContentAddress"`
	FlaggedVersionID        *string       `json:"flaggedVersionID,omitempty"`
	FlaggedVersionName      *string       `json:"flaggedVersionName,omitempty"`
	FlaggedVersionCreatedAt *time.Time    `json:"flaggedVersionCreatedAt,omitempty"`
	FlaggedByUser           *models.User  `json:"flaggedByUser,omitempty"`
	State                   TLUpdateState `json:"state"`
}

func (TLUpdateV1) IsTLEventPayload() {}

type TimelineMessageInput struct {
	ReplyTo           *string `json:"replyTo,omitempty"`
	AuthorID          string  `json:"authorId"`
	Content           string  `json:"content"`
	ContentAddress    string  `json:"contentAddress"`
	StartID           *string `json:"startID,omitempty"`
	EndID             *string `json:"endID,omitempty"`
	SelectionMarkdown *string `json:"selectionMarkdown,omitempty"`
}

type UnauthenticatedSharedLink struct {
	InviteLink     string `json:"inviteLink"`
	DocumentTitle  string `json:"documentTitle"`
	InvitedByEmail string `json:"invitedByEmail"`
	InvitedByName  string `json:"invitedByName"`
}

type UpdateMessageResolutionInput struct {
	Resolved bool   `json:"resolved"`
	AuthorID string `json:"authorID"`
}

type UpdateUserInput struct {
	Name        string `json:"name"`
	DisplayName string `json:"displayName"`
}

type UpdateUserPreferenceInput struct {
	EnableActivityNotifications *bool `json:"enableActivityNotifications,omitempty"`
}

type AttachmentInputType string

const (
	AttachmentInputTypeUnknown AttachmentInputType = "UNKNOWN"
	AttachmentInputTypeFile    AttachmentInputType = "FILE"
	AttachmentInputTypeDraft   AttachmentInputType = "DRAFT"
)

var AllAttachmentInputType = []AttachmentInputType{
	AttachmentInputTypeUnknown,
	AttachmentInputTypeFile,
	AttachmentInputTypeDraft,
}

func (e AttachmentInputType) IsValid() bool {
	switch e {
	case AttachmentInputTypeUnknown, AttachmentInputTypeFile, AttachmentInputTypeDraft:
		return true
	}
	return false
}

func (e AttachmentInputType) String() string {
	return string(e)
}

func (e *AttachmentInputType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AttachmentInputType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AttachmentInputType", str)
	}
	return nil
}

func (e AttachmentInputType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AttachmentProgressType string

const (
	AttachmentProgressTypeUnknown  AttachmentProgressType = "UNKNOWN"
	AttachmentProgressTypeThinking AttachmentProgressType = "THINKING"
	AttachmentProgressTypeDone     AttachmentProgressType = "DONE"
)

var AllAttachmentProgressType = []AttachmentProgressType{
	AttachmentProgressTypeUnknown,
	AttachmentProgressTypeThinking,
	AttachmentProgressTypeDone,
}

func (e AttachmentProgressType) IsValid() bool {
	switch e {
	case AttachmentProgressTypeUnknown, AttachmentProgressTypeThinking, AttachmentProgressTypeDone:
		return true
	}
	return false
}

func (e AttachmentProgressType) String() string {
	return string(e)
}

func (e *AttachmentProgressType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AttachmentProgressType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AttachmentProgressType", str)
	}
	return nil
}

func (e AttachmentProgressType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ChanType string

const (
	ChanTypeUnknown ChanType = "UNKNOWN"
	ChanTypeReviso  ChanType = "REVISO"
	ChanTypeDirect  ChanType = "DIRECT"
	ChanTypeGeneral ChanType = "GENERAL"
)

var AllChanType = []ChanType{
	ChanTypeUnknown,
	ChanTypeReviso,
	ChanTypeDirect,
	ChanTypeGeneral,
}

func (e ChanType) IsValid() bool {
	switch e {
	case ChanTypeUnknown, ChanTypeReviso, ChanTypeDirect, ChanTypeGeneral:
		return true
	}
	return false
}

func (e ChanType) String() string {
	return string(e)
}

func (e *ChanType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChanType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChanType", str)
	}
	return nil
}

func (e ChanType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CommentNotificationType string

const (
	CommentNotificationTypeUnknown CommentNotificationType = "UNKNOWN"
	CommentNotificationTypeComment CommentNotificationType = "COMMENT"
	CommentNotificationTypeReply   CommentNotificationType = "REPLY"
	CommentNotificationTypeMention CommentNotificationType = "MENTION"
)

var AllCommentNotificationType = []CommentNotificationType{
	CommentNotificationTypeUnknown,
	CommentNotificationTypeComment,
	CommentNotificationTypeReply,
	CommentNotificationTypeMention,
}

func (e CommentNotificationType) IsValid() bool {
	switch e {
	case CommentNotificationTypeUnknown, CommentNotificationTypeComment, CommentNotificationTypeReply, CommentNotificationTypeMention:
		return true
	}
	return false
}

func (e CommentNotificationType) String() string {
	return string(e)
}

func (e *CommentNotificationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommentNotificationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommentNotificationType", str)
	}
	return nil
}

func (e CommentNotificationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LifecycleStage string

const (
	LifecycleStageUnknown   LifecycleStage = "UNKNOWN"
	LifecycleStagePending   LifecycleStage = "PENDING"
	LifecycleStageRevising  LifecycleStage = "REVISING"
	LifecycleStageRevised   LifecycleStage = "REVISED"
	LifecycleStageCompleted LifecycleStage = "COMPLETED"
)

var AllLifecycleStage = []LifecycleStage{
	LifecycleStageUnknown,
	LifecycleStagePending,
	LifecycleStageRevising,
	LifecycleStageRevised,
	LifecycleStageCompleted,
}

func (e LifecycleStage) IsValid() bool {
	switch e {
	case LifecycleStageUnknown, LifecycleStagePending, LifecycleStageRevising, LifecycleStageRevised, LifecycleStageCompleted:
		return true
	}
	return false
}

func (e LifecycleStage) String() string {
	return string(e)
}

func (e *LifecycleStage) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LifecycleStage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LifecycleStage", str)
	}
	return nil
}

func (e LifecycleStage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MessageRevisionStatus string

const (
	MessageRevisionStatusUnspecified MessageRevisionStatus = "UNSPECIFIED"
	MessageRevisionStatusAccepted    MessageRevisionStatus = "ACCEPTED"
	MessageRevisionStatusDeclined    MessageRevisionStatus = "DECLINED"
)

var AllMessageRevisionStatus = []MessageRevisionStatus{
	MessageRevisionStatusUnspecified,
	MessageRevisionStatusAccepted,
	MessageRevisionStatusDeclined,
}

func (e MessageRevisionStatus) IsValid() bool {
	switch e {
	case MessageRevisionStatusUnspecified, MessageRevisionStatusAccepted, MessageRevisionStatusDeclined:
		return true
	}
	return false
}

func (e MessageRevisionStatus) String() string {
	return string(e)
}

func (e *MessageRevisionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MessageRevisionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MessageRevisionStatus", str)
	}
	return nil
}

func (e MessageRevisionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MsgLlm string

const (
	MsgLlmClaude MsgLlm = "CLAUDE"
	MsgLlmGpt4o  MsgLlm = "GPT4O"
)

var AllMsgLlm = []MsgLlm{
	MsgLlmClaude,
	MsgLlmGpt4o,
}

func (e MsgLlm) IsValid() bool {
	switch e {
	case MsgLlmClaude, MsgLlmGpt4o:
		return true
	}
	return false
}

func (e MsgLlm) String() string {
	return string(e)
}

func (e *MsgLlm) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MsgLlm(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MsgLLM", str)
	}
	return nil
}

func (e MsgLlm) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Status string

const (
	StatusLoading Status = "LOADING"
	StatusSuccess Status = "SUCCESS"
	StatusError   Status = "ERROR"
)

var AllStatus = []Status{
	StatusLoading,
	StatusSuccess,
	StatusError,
}

func (e Status) IsValid() bool {
	switch e {
	case StatusLoading, StatusSuccess, StatusError:
		return true
	}
	return false
}

func (e Status) String() string {
	return string(e)
}

func (e *Status) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Status(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Status", str)
	}
	return nil
}

func (e Status) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TLUpdateState string

const (
	TLUpdateStateComplete    TLUpdateState = "COMPLETE"
	TLUpdateStateSummarizing TLUpdateState = "SUMMARIZING"
)

var AllTLUpdateState = []TLUpdateState{
	TLUpdateStateComplete,
	TLUpdateStateSummarizing,
}

func (e TLUpdateState) IsValid() bool {
	switch e {
	case TLUpdateStateComplete, TLUpdateStateSummarizing:
		return true
	}
	return false
}

func (e TLUpdateState) String() string {
	return string(e)
}

func (e *TLUpdateState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TLUpdateState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TLUpdateState", str)
	}
	return nil
}

func (e TLUpdateState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TimelineEventFilter string

const (
	TimelineEventFilterAll      TimelineEventFilter = "ALL"
	TimelineEventFilterComments TimelineEventFilter = "COMMENTS"
	TimelineEventFilterEdits    TimelineEventFilter = "EDITS"
)

var AllTimelineEventFilter = []TimelineEventFilter{
	TimelineEventFilterAll,
	TimelineEventFilterComments,
	TimelineEventFilterEdits,
}

func (e TimelineEventFilter) IsValid() bool {
	switch e {
	case TimelineEventFilterAll, TimelineEventFilterComments, TimelineEventFilterEdits:
		return true
	}
	return false
}

func (e TimelineEventFilter) String() string {
	return string(e)
}

func (e *TimelineEventFilter) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimelineEventFilter(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimelineEventFilter", str)
	}
	return nil
}

func (e TimelineEventFilter) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
