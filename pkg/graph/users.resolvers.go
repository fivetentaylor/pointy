package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.35

import (
	"context"
	"fmt"

	"github.com/charmbracelet/log"
	"github.com/teamreviso/code/pkg/constants"
	"github.com/teamreviso/code/pkg/env"
	"github.com/teamreviso/code/pkg/graph/model"
	"github.com/teamreviso/code/pkg/models"
	"github.com/teamreviso/code/pkg/service/images"
	"github.com/teamreviso/code/pkg/service/messaging"
	"github.com/teamreviso/code/pkg/service/payments"
)

// UpdateMe is the resolver for the updateMe field.
func (r *mutationResolver) UpdateMe(ctx context.Context, input model.UpdateUserInput) (*models.User, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("we could not find you")
	}

	userTbl := env.Query(ctx).User
	me, err := userTbl.Where(userTbl.ID.Eq(currentUser.Id)).First()
	if err != nil {
		log.Errorf("error getting current user from db: %s", err)
		return nil, fmt.Errorf("we could not find you")
	}

	me.Name = input.Name
	me.DisplayName = input.DisplayName

	err = userTbl.Save(me)
	if err != nil {
		log.Errorf("error updating user: %s", err)
		return nil, err
	}

	return me, nil
}

// UpdateMyPreference is the resolver for the updateMyPreference field.
func (r *mutationResolver) UpdateMyPreference(ctx context.Context, input model.UpdateUserPreferenceInput) (*models.UserPreference, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("we could not find you")
	}

	dpref, err := env.Dynamo(ctx).GetUserPreference(currentUser.Id)
	if err != nil {
		log.Errorf("error getting user preference: %s", err)
		return nil, err
	}

	if input.EnableActivityNotifications != nil {
		dpref.Preference.EnableActivityNotifications = *input.EnableActivityNotifications
	}

	err = env.Dynamo(ctx).UpsertUserPreference(dpref)
	if err != nil {
		log.Errorf("error updating user preference: %s", err)
		return nil, err
	}

	return dpref.Preference, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("we could not find you")
	}

	userTbl := env.Query(ctx).User
	return userTbl.Where(userTbl.ID.Eq(currentUser.Id)).First()
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*models.User, error) {
	q := env.Query(ctx)
	return q.User.Where(q.User.ID.Eq(id)).First()
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, ids []string) ([]*models.User, error) {
	q := env.Query(ctx)
	return q.User.Where(q.User.ID.In(ids...)).Find()
}

// UsersInMyDomain is the resolver for the usersInMyDomain field.
func (r *queryResolver) UsersInMyDomain(ctx context.Context, includeSelf *bool) ([]*models.User, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		return nil, fmt.Errorf("could not find current user: %w", err)
	}

	db := env.RawDB(ctx)
	query := `
        WITH collaborators AS (
            SELECT DISTINCT da2.user_id AS collaborator_id
            FROM document_access da1
            JOIN document_access da2 ON da1.document_id = da2.document_id AND da1.user_id != da2.user_id
            WHERE da1.user_id = ?
        )
        SELECT u.*
        FROM collaborators c
        JOIN users u ON c.collaborator_id = u.id
        WHERE u.id != ?
    `
	args := []interface{}{currentUser.Id, constants.RevisoUserID}

	if includeSelf != nil && *includeSelf {
		query += `
            UNION ALL
            SELECT * FROM users WHERE id = ?
        `
		args = append(args, currentUser.Id)
	}

	var users []*models.User
	if err := db.Raw(query, args...).Scan(&users).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch users: %w", err)
	}

	return users, nil
}

// MyPreference is the resolver for the myPreference field.
func (r *queryResolver) MyPreference(ctx context.Context) (*models.UserPreference, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return nil, fmt.Errorf("we could not find you")
	}

	dpref, err := env.Dynamo(ctx).GetUserPreference(currentUser.Id)
	if err != nil {
		log.Errorf("error getting user preference: %s", err)
		return nil, err
	}

	return dpref.Preference, nil
}

// Picture is the resolver for the picture field.
func (r *userResolver) Picture(ctx context.Context, obj *models.User) (*string, error) {
	return images.AvatarUrlForUser(ctx, obj)
}

// IsAdmin is the resolver for the isAdmin field.
func (r *userResolver) IsAdmin(ctx context.Context, obj *models.User) (bool, error) {
	currentUser, err := env.UserClaim(ctx)
	if err != nil {
		log.Errorf("error getting current user: %s", err)
		return false, fmt.Errorf("we could not find you")
	}

	if !currentUser.Admin {
		// non-admins can only see if a user is an admin
		return false, nil
	}

	return obj.Admin, nil
}

// SubscriptionStatus is the resolver for the subscriptionStatus field.
func (r *userResolver) SubscriptionStatus(ctx context.Context, obj *models.User) (string, error) {
	log := env.SLog(ctx)
	status, err := payments.UserSubscriptionStatus(ctx, obj.ID)
	if err != nil {
		log.Error("error getting subscription status", "error", err)
		return "", err
	}

	return status, nil
}

// MessagingLimit is the resolver for the messagingLimit field.
func (r *userResolver) MessagingLimit(ctx context.Context, obj *models.User) (*models.MessagingLimit, error) {
	log := env.SLog(ctx)
	limit, err := messaging.MessageLimit(ctx, obj.ID)
	if err != nil {
		log.Error("error getting messaging limit", "error", err)
		return nil, err
	}

	return limit, nil
}

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
